# Default values for llm-proxy.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: llm-proxy
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

podAnnotations: {}
podLabels: {}

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000
  fsGroup: 1000

securityContext:
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false

service:
  type: ClusterIP
  port: 8080
  targetPort: 8080
  annotations: {}

resources:
  limits:
    cpu: 1000m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 128Mi

livenessProbe:
  httpGet:
    path: /live
    port: http
  initialDelaySeconds: 10
  periodSeconds: 30
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /ready
    port: http
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

# Additional volumes on the output Deployment definition.
volumes:
  - name: tmp
    emptyDir: {}
  - name: data
    emptyDir: {}
  - name: logs
    emptyDir: {}
  - name: config
    emptyDir: {}

# Additional volumeMounts on the output Deployment definition.
volumeMounts:
  - name: tmp
    mountPath: /tmp
  - name: data
    mountPath: /app/data
  - name: logs
    mountPath: /app/logs
  - name: config
    mountPath: /app/config

nodeSelector: {}

tolerations: []

affinity: {}

# Environment variables (non-sensitive)
env:
  LISTEN_ADDR: ":8080"
  LOG_LEVEL: "info"
  LOG_FORMAT: "json"
  LOG_FILE: ""
  ENABLE_METRICS: "true"
  METRICS_PATH: "/metrics"
  # Database driver: sqlite (default) or postgres for external PostgreSQL
  DB_DRIVER: "sqlite"
  # Path to SQLite database file (used when DB_DRIVER=sqlite)
  DATABASE_PATH: "/app/data/llm-proxy.db"
  # Event bus backend: in-memory (default), redis-streams, or redis
  # in-memory: Uses in-memory channel (single-process only, no Redis required)
  # redis-streams: Uses Redis Streams with consumer groups for durable, distributed delivery
  # redis: Uses Redis List-based event queue
  # NOTE: When using redis or redis-streams, you must configure redis.external.addr below
  LLM_PROXY_EVENT_BUS: "in-memory"

# Secrets configuration
# SECURITY: Never store secrets in values.yaml or version control
# Best practice: reference existing Kubernetes Secrets created separately
secrets:
  # Create a Kubernetes Secret managed by this chart (NOT RECOMMENDED for production)
  # When false (default), you must create secrets externally and reference them below
  create: false
  
  # Chart-managed secret values (only used when secrets.create=true)
  # SECURITY WARNING: These values should be overridden via --set-string or --set-file
  # Example: helm install --set-string secrets.data.managementToken="your-token"
  data:
    managementToken: ""
    databaseUrl: ""
  
  # MANAGEMENT_TOKEN: Required for admin operations
  # Reference an existing Kubernetes Secret containing the management token
  managementToken:
    existingSecret:
      # Name of the existing Kubernetes Secret
      name: ""
      # Key within the Secret that contains the management token value
      key: "MANAGEMENT_TOKEN"
  
  # DATABASE_URL: Required when DB_DRIVER=postgres
  # Reference an existing Kubernetes Secret containing the database URL
  databaseUrl:
    existingSecret:
      # Name of the existing Kubernetes Secret
      name: ""
      # Key within the Secret that contains the database URL
      key: "DATABASE_URL"

# PostgreSQL configuration
# IMPORTANT: When using PostgreSQL (either in-cluster or external), ensure your Docker image
# is built with PostgreSQL support using the 'postgres' build tag.
# Default images built with: docker build --build-arg POSTGRES_SUPPORT=true
postgresql:
  # Enable in-cluster PostgreSQL (development/testing only)
  # When true, deploys a PostgreSQL database as part of this chart
  # For production, use external PostgreSQL with secrets.databaseUrl.existingSecret
  enabled: false
  
  # Bitnami PostgreSQL subchart configuration
  # Only applies when postgresql.enabled=true
  # For full options, see: https://github.com/bitnami/charts/tree/main/bitnami/postgresql
  auth:
    # PostgreSQL admin username
    username: llmproxy
    # PostgreSQL database name
    database: llmproxy
    # PostgreSQL password (override with --set-string for security)
    # Example: --set-string postgresql.auth.password="$(openssl rand -base64 32)"
    password: ""
    # Use existing secret for PostgreSQL password (recommended)
    # When set, overrides postgresql.auth.password
    existingSecret: ""
    secretKeys:
      adminPasswordKey: postgres-password
      userPasswordKey: password
  
  # PostgreSQL primary configuration
  primary:
    persistence:
      enabled: true
      size: 8Gi
    resources:
      limits:
        memory: 256Mi
        cpu: 500m
      requests:
        memory: 128Mi
        cpu: 100m
  
  # SSL mode for PostgreSQL connections (require, verify-ca, verify-full, or disable)
  # SECURITY: Use 'require' or stronger for production environments
  # Only use 'disable' in trusted development environments
  sslMode: "require"

# Redis configuration
# Used for event bus, optional HTTP cache, and optional distributed rate limiting
redis:
  # Enable in-cluster Redis (development/testing only, not currently implemented)
  # When false, you can either configure external Redis below or use in-memory event bus (LLM_PROXY_EVENT_BUS=in-memory)
  enabled: false
  
  # External Redis configuration (recommended for production)
  external:
    # Redis server address used when LLM_PROXY_EVENT_BUS is set to redis or redis-streams
    # Format: host:port (e.g., "redis.example.com:6379")
    # Leave empty when using in-memory event bus
    addr: ""
    # Redis database number (default: 0)
    db: 0
    # Optional: Reference an existing Kubernetes Secret containing Redis password
    # If not set, assumes Redis has no authentication
    password:
      existingSecret:
        # Name of the existing Kubernetes Secret containing Redis password
        name: ""
        # Key within the Secret that contains the Redis password
        key: "REDIS_PASSWORD"

# Dispatcher configuration
# The dispatcher is an optional separate workload that consumes events from the event bus
# and forwards them to external observability platforms (Lunary, Helicone, or file storage)
dispatcher:
  # Enable optional dispatcher deployment
  enabled: false
  
  # Number of dispatcher replicas
  replicaCount: 1
  
  # Dispatcher backend service (file, lunary, helicone)
  service: "file"
  
  # Service-specific endpoint
  # - file: /app/data/events.jsonl (mounted via PV)
  # - lunary: https://api.lunary.ai/v1/runs/ingest (default)
  # - helicone: https://api.worker.helicone.ai/custom/v1/log (default)
  endpoint: ""
  
  # API key configuration (for lunary/helicone)
  apiKey:
    # Direct value (not recommended for production)
    value: ""
    # Reference existing secret (recommended, follows PostgreSQL pattern)
    existingSecret:
      name: ""
      key: "DISPATCHER_API_KEY"
  
  # Dispatcher tuning
  config:
    bufferSize: 1000
    batchSize: 100
  
  # Persistence (for file backend)
  persistence:
    enabled: true  # auto-enabled when service=file
    size: 10Gi
    storageClass: ""
  
  # Pod security context (inherits from main deployment if not overridden)
  podSecurityContext: {}
  
  # Container security context (inherits from main deployment if not overridden)
  securityContext: {}
  
  # Resource limits for dispatcher
  resources:
    limits:
      cpu: 500m
      memory: 256Mi
    requests:
      cpu: 100m
      memory: 128Mi
  
  # Node selector for dispatcher pods
  nodeSelector: {}
  
  # Tolerations for dispatcher pods
  tolerations: []
  
  # Affinity rules for dispatcher pods
  affinity: {}
