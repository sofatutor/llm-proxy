# Default values for llm-proxy.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: llm-proxy
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

podAnnotations: {}
podLabels: {}

podSecurityContext:
  runAsNonRoot: true
  # Kubelet can't verify non-root for non-numeric image users; set stable numeric IDs.
  runAsUser: 100
  runAsGroup: 101
  # Rely on the container image's non-root user by default, and ensure mounted
  # writable volumes are group-writable.
  fsGroup: 101
  fsGroupChangePolicy: OnRootMismatch

securityContext:
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false

service:
  type: ClusterIP
  port: 8080
  targetPort: 8080
  annotations: {}

ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # cert-manager.io/cluster-issuer: letsencrypt-prod
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: Prefix
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

# Optional Admin UI (separate workload)
admin:
  enabled: false
  listenAddr: ":8081"
  livenessProbe:
    httpGet:
      path: /auth/login
      port: http
    initialDelaySeconds: 10
    periodSeconds: 30
    timeoutSeconds: 5
    failureThreshold: 3
  readinessProbe:
    httpGet:
      path: /auth/login
      port: http
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
  service:
    type: ClusterIP
    port: 8081
    annotations: {}
  ingress:
    enabled: false
    className: ""
    annotations: {}
    hosts:
      - host: admin.chart-example.local
        paths:
          - path: /
            pathType: Prefix
    tls: []
  # Optional override for the base URL the admin uses to reach the main service (e.g., https://proxy.example.com)
  apiBaseUrl: ""

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

resources:
  limits:
    cpu: 1000m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 128Mi

livenessProbe:
  httpGet:
    path: /live
    port: http
  initialDelaySeconds: 10
  periodSeconds: 30
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /ready
    port: http
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

# Additional volumes on the output Deployment definition.
volumes:
  - name: tmp
    emptyDir: {}
  - name: data
    emptyDir: {}
  - name: logs
    emptyDir: {}
  - name: config
    emptyDir: {}
  - name: certs
    emptyDir: {}

# Additional volumeMounts on the output Deployment definition.
volumeMounts:
  - name: tmp
    mountPath: /tmp
  - name: data
    mountPath: /app/data
  - name: logs
    mountPath: /app/logs
  - name: config
    mountPath: /app/config
  - name: certs
    mountPath: /app/certs

nodeSelector: {}

tolerations: []

affinity: {}

# Environment variables (non-sensitive)
env:
  LISTEN_ADDR: ":8080"
  LOG_LEVEL: "info"
  LOG_FORMAT: "json"
  LOG_FILE: ""
  ENABLE_METRICS: "true"
  METRICS_PATH: "/metrics"
  # Database driver: sqlite (default) or postgres for external PostgreSQL
  DB_DRIVER: "sqlite"
  # Path to SQLite database file (used when DB_DRIVER=sqlite)
  DATABASE_PATH: "/app/data/llm-proxy.db"
  # Event bus backend: in-memory (default), redis-streams, or redis
  # in-memory: Uses in-memory channel (single-process only, no Redis required)
  # redis-streams: Uses Redis Streams with consumer groups for durable, distributed delivery
  # redis: Uses Redis List-based event queue
  # NOTE: When using redis or redis-streams, you must configure redis.external.addr below
  LLM_PROXY_EVENT_BUS: "in-memory"

# Secrets configuration
# SECURITY: Never store secrets in values.yaml or version control
# Best practice: reference existing Kubernetes Secrets created separately
secrets:
  # Create a Kubernetes Secret managed by this chart (NOT RECOMMENDED for production)
  # When false (default), you must create secrets externally and reference them below
  create: false
  
  # Chart-managed secret values (only used when secrets.create=true)
  # SECURITY WARNING: These values should be overridden via --set-string or --set-file
  # Example: helm install --set-string secrets.data.managementToken="your-token"
  data:
    managementToken: ""
    databaseUrl: ""
  
  # MANAGEMENT_TOKEN: Required for admin operations
  # Reference an existing Kubernetes Secret containing the management token
  managementToken:
    existingSecret:
      # Name of the existing Kubernetes Secret
      name: ""
      # Key within the Secret that contains the management token value
      key: "MANAGEMENT_TOKEN"
  
  # DATABASE_URL: Required when DB_DRIVER=postgres
  # Reference an existing Kubernetes Secret containing the database URL
  databaseUrl:
    existingSecret:
      # Name of the existing Kubernetes Secret
      name: ""
      # Key within the Secret that contains the database URL
      key: "DATABASE_URL"
  
  # ENCRYPTION_KEY: Strongly recommended for production
  # Encrypts API keys (AES-256-GCM) and hashes tokens (SHA-256)
  # Generate with: openssl rand -base64 32
  # Reference an existing Kubernetes Secret containing the encryption key
  encryptionKey:
    existingSecret:
      # Name of the existing Kubernetes Secret
      name: ""
      # Key within the Secret that contains the encryption key
      key: "ENCRYPTION_KEY"

# PostgreSQL configuration
# IMPORTANT: When using PostgreSQL (either in-cluster or external), ensure your Docker image
# is built with PostgreSQL support using the 'postgres' build tag.
# Default images built with: docker build --build-arg POSTGRES_SUPPORT=true
postgresql:
  # Enable in-cluster PostgreSQL (development/testing only)
  # When true, deploys a PostgreSQL database as part of this chart
  # For production, use external PostgreSQL with secrets.databaseUrl.existingSecret
  enabled: false
  
  # Bitnami PostgreSQL subchart configuration
  # Only applies when postgresql.enabled=true
  # For full options, see: https://github.com/bitnami/charts/tree/main/bitnami/postgresql
  auth:
    # PostgreSQL admin username
    username: llmproxy
    # PostgreSQL database name
    database: llmproxy
    # PostgreSQL password (override with --set-string for security)
    # Example: --set-string postgresql.auth.password="$(openssl rand -base64 32)"
    password: ""
    # Use existing secret for PostgreSQL password (recommended)
    # When set, overrides postgresql.auth.password
    existingSecret: ""
    secretKeys:
      adminPasswordKey: postgres-password
      userPasswordKey: password
  
  # PostgreSQL primary configuration
  primary:
    persistence:
      enabled: true
      size: 8Gi
    resources:
      limits:
        memory: 256Mi
        cpu: 500m
      requests:
        memory: 128Mi
        cpu: 100m
  
  # SSL mode for PostgreSQL connections (require, verify-ca, verify-full, or disable)
  # SECURITY: Use 'require' or stronger for production environments
  # Only use 'disable' in trusted development environments
  sslMode: "require"

# MySQL configuration
# IMPORTANT: When using MySQL (either in-cluster or external), ensure your Docker image
# is built with MySQL support using the 'mysql' build tag.
# Default images built with: docker build --build-arg MYSQL_SUPPORT=true
mysql:
  # Enable in-cluster MySQL (development/testing only)
  # When true, deploys a MySQL database as part of this chart
  # For production, use external MySQL with secrets.databaseUrl.existingSecret
  enabled: false
  
  # MySQL image configuration
  image:
    # MySQL Docker image repository
    repository: mysql
    # MySQL version tag
    tag: "8.0"
    # Image pull policy
    pullPolicy: IfNotPresent
  
  # MySQL authentication configuration
  auth:
    # MySQL root password (override with --set-string for security)
    # Example: --set-string mysql.auth.rootPassword="$(openssl rand -base64 32)"
    rootPassword: ""
    # MySQL database name
    database: llmproxy
    # MySQL application username
    username: llmproxy
    # MySQL application password (override with --set-string for security)
    # Example: --set-string mysql.auth.password="$(openssl rand -base64 32)"
    password: ""
    # Use existing secret for MySQL passwords (recommended)
    # When set, overrides mysql.auth.rootPassword and mysql.auth.password
    existingSecret: ""
    secretKeys:
      rootPasswordKey: mysql-root-password
      userPasswordKey: mysql-password
  
  # MySQL persistence configuration
  persistence:
    # Enable persistence using PVC
    enabled: true
    # Storage class for PVC
    # If undefined (the default) or set to null, no storageClassName spec is set
    # choosing the default provisioner (gp2 on AWS, standard on GKE, AWS & OpenStack)
    storageClass: ""
    # Size of the PVC
    size: 10Gi
    # Access mode for the PVC
    accessMode: ReadWriteOnce
  
  # MySQL resource limits and requests
  resources:
    limits:
      memory: 1Gi
      cpu: 1000m
    requests:
      memory: 256Mi
      cpu: 100m
  
  # MySQL-specific configuration options
  # These are passed as command-line arguments to mysqld
  extraConfig:
    # Maximum number of connections (default: 151)
    maxConnections: 200
    # Character set (default: utf8mb4)
    characterSet: utf8mb4
    # Collation (default: utf8mb4_unicode_ci)
    collation: utf8mb4_unicode_ci
  
  # TLS/SSL configuration for MySQL connections
  # SECURITY: Use 'true' for production environments
  # Only use 'false' in trusted development environments
  tls:
    # Enable TLS for MySQL connections
    enabled: false
    # Skip TLS certificate verification (not recommended for production)
    # Only applicable when tls.enabled=true
    skipVerify: false

# Redis configuration
# Used for event bus, optional HTTP cache, and optional distributed rate limiting
redis:
  # Enable in-cluster Redis (development/testing only, not currently implemented)
  # When false, you can either configure external Redis below or use in-memory event bus (LLM_PROXY_EVENT_BUS=in-memory)
  enabled: false
  
  # External Redis configuration (recommended for production)
  external:
    # Redis server address used when LLM_PROXY_EVENT_BUS is set to redis or redis-streams
    # Format: host:port (e.g., "redis.example.com:6379")
    # Leave empty when using in-memory event bus
    addr: ""
    # Redis database number (default: 0)
    db: 0
    # Optional: Reference an existing Kubernetes Secret containing Redis password
    # If not set, assumes Redis has no authentication
    password:
      existingSecret:
        # Name of the existing Kubernetes Secret containing Redis password
        name: ""
        # Key within the Secret that contains the Redis password
        key: "REDIS_PASSWORD"

# Dispatcher configuration
# The dispatcher is an optional separate workload that consumes events from the event bus
# and forwards them to external observability platforms (Lunary, Helicone, or file storage)
dispatcher:
  # Enable optional dispatcher deployment
  enabled: false
  
  # Number of dispatcher replicas
  replicaCount: 1
  
  # Dispatcher backend service (file, lunary, helicone)
  service: "file"
  
  # Service-specific endpoint
  # - file: /app/data/events.jsonl (mounted via PV)
  # - lunary: https://api.lunary.ai/v1/runs/ingest (default)
  # - helicone: https://api.worker.helicone.ai/custom/v1/log (default)
  endpoint: ""
  
  # API key configuration (for lunary/helicone)
  # API keys must be provided via existingSecret for security
  apiKey:
    existingSecret:
      name: ""
      key: "DISPATCHER_API_KEY"
  
  # Dispatcher tuning
  config:
    bufferSize: 1000
    batchSize: 100
  
  # Persistence (for file backend)
  persistence:
    enabled: true  # enabled by default; set to false to disable PVC creation
    size: 10Gi
    storageClass: ""
  
  # Pod security context (inherits from main deployment if not overridden)
  podSecurityContext: {}
  
  # Container security context (inherits from main deployment if not overridden)
  securityContext: {}
  
  # Resource limits for dispatcher
  resources:
    limits:
      cpu: 500m
      memory: 256Mi
    requests:
      cpu: 100m
      memory: 128Mi
  
  # Node selector for dispatcher pods
  nodeSelector: {}
  
  # Tolerations for dispatcher pods
  tolerations: []
  
  # Affinity rules for dispatcher pods
  affinity: {}

# Prometheus metrics scraping configuration
# The application exposes metrics at /metrics/prometheus when ENABLE_METRICS=true
metrics:
  # Enable Prometheus metrics scraping support (opt-in)
  enabled: false
  
  # Metrics endpoint path (must match METRICS_PATH + "/prometheus" in env)
  path: "/metrics/prometheus"
  
  # Port name to scrape (references service.port)
  # The port number is inherited from service.port
  portName: "http"
  
  # Prometheus scraping via Service annotations (for vanilla Prometheus)
  # Only applied when metrics.enabled=true
  # Customize or override these annotations as needed
  # NOTE: The port annotation must match service.port. If you change service.port,
  # update this annotation accordingly.
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/path: "/metrics/prometheus"
    prometheus.io/port: "8080"
  
  # ServiceMonitor configuration (for Prometheus Operator)
  # Requires Prometheus Operator CRDs to be installed
  serviceMonitor:
    # Enable ServiceMonitor resource creation
    enabled: false
    
    # Additional labels for ServiceMonitor (e.g., for Prometheus discovery)
    # Example: { prometheus: kube-prometheus }
    labels: {}
    
    # Scrape interval
    interval: 30s
    
    # Scrape timeout
    scrapeTimeout: 10s
    
    # Additional ServiceMonitor configuration
    # Uncomment and customize as needed:
    # honorLabels: false
    # relabelings: []
    # metricRelabelings: []
  
  # Grafana dashboard configuration
  # Creates a ConfigMap with the dashboard JSON for Grafana sidecar discovery
  grafanaDashboard:
    # Enable Grafana dashboard ConfigMap creation
    enabled: false
    
    # Additional labels for ConfigMap (required for Grafana sidecar discovery)
    # Example: { grafana_dashboard: "1" }
    labels:
      grafana_dashboard: "1"
    
    # Annotations for ConfigMap
    annotations: {}

  # Redis Grafana dashboard configuration
  # Creates a ConfigMap with a Redis metrics dashboard JSON for Grafana sidecar discovery.
  # NOTE: This dashboard assumes Prometheus job labels like: llm-proxy-redis-(cache|events)-metrics
  redisDashboard:
    enabled: false
    labels:
      grafana_dashboard: "1"
    annotations: {}
